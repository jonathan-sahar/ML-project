__author__ = 'Inspiron'
import os
import csv #TODO make sure doesn't use csv because in featureCalculationFunctions
import re
from constants import *
import numpy as np
from featureCalculationFunctions import *


def aggregate(aggregators, windowType, dataWindow, aggregatedWindows):
    '''

    :param aggregators:
    :param windowType:
    :param dataWindow:
    :param aggregatedWindows:
    :return: headers: the list of headers matching output of all functions in aggregators
    :return: aggregatedWindow: the line of values generated by the aggregators for this time window.
    '''
    headers = []
    aggregatedWindow = np.atleast_2d([])
    for func in aggregators:
        if windowType == 'short':
            header, data = func(dataWindow)
        elif windowType == 'long':
            header, data = func(dataWindow, aggregatedWindows)
        else: #windowType == 'entire'
            header, data = func(dataWindow, aggregatedWindows)
        headers.extend(header)
        aggregatedWindow = np.hstack((aggregatedWindow, np.atleast_2d(data)))

    return headers, aggregatedWindow

def createTimeWindowTable(aggregatorsList, windowType, dataWindows, aggregatedWindows):
    '''

    :param aggregatorsList: list of functions that reduce the data in a window to a single line
    :param windowType: one of 'short' , 'long', 'entire'
    :param dataWindows: list of (structured) arrays
    :param aggregatedWindows:  list of reduced windows, either short, if windowType is 'long', or long windows if windowType is 'entire'
    :return: a structured array: contains a line for every window in dataWindows.
    '''
    if windowType == 'short':
        header, firstAggregatedWindow = aggregate(aggregatorsList, windowType, dataWindows[0], None)
        table = [firstAggregatedWindow]
        for timeWindow in dataWindows[1:]:
            _, row = aggregate(aggregatorsList, windowType, timeWindow, None)
            table.append(row)
    else:
        if windowType == 'long':
            if not len(dataWindows) == len(aggregatedWindows):
                print "{}, {}".format(len(dataWindows), len(aggregatedWindows))
                exit()
        print "{}, {}".format(len(dataWindows), len(aggregatedWindows))
        aggIter = iter(aggregatedWindows)
        header, firstAggregatedWindow = aggregate(aggregatorsList, windowType, dataWindows[0], aggIter.next())
        table = [firstAggregatedWindow]
        for timeWindow in dataWindows[1:]:
            item = aggIter.next()
            _, row = aggregate(aggregatorsList, windowType, timeWindow, item)
            table.append(row)
    dt = zip(header, len(header)*['f4']) # TODO: set the field type in a constant. are 4 bytes enough?
    rows = [tuple(list(row[0])) for row in table]
    if not len(rows[0]) == len(dt):
        print "len rows: ", len(rows[0])
        print "len dt: ", len(dt)
        print " rows: ", (rows[0])
        print " dt: ", (dt)
    ret = np.array(rows, dtype=dt)
    return ret


def divideToWindows(dataMatrix, windowLength):
    '''
    :param dataMatrix:
    :param windowLength:
`    :return: windows is a list of arrays
    '''
    divided =  [dataMatrix[a:a+windowLength] for a in range(0, len(dataMatrix)-windowLength + 1, windowLength)]
    return  divided

    # firtsIteration = True
    # if dataMatrix == []:
    #     return []
    # windows =[]
    # window = []
    # lineCounter = 0
    # for row in dataMatrix:
    #     lineCounter +=1
    #     window.append(row)
    #     if firtsIteration == True:
    #         if lineCounter == windowLength+1:
    #             lineCounter = 0
    #             windows.append(window)
    #             window = []
    #             firtsIteration = False
    #     else:
    #         if lineCounter == windowLength:
    #             lineCounter = 0
    #             windows.append(window)
    #             window = []
    # return windows


def readFileToFloat(filePath):
    '''
    Assumes file  contains headers
    :param filePath:
    :return:
    '''
    newFile = open(filePath, 'r')
    data = np.genfromtxt(filePath, dtype=float, delimiter=',', names = True, case_sensitive=True)
    field_names = np.array(data.dtype.names)
    r = re.compile(r'(.*time.*|.*patient.*|.*sick.*)',re.IGNORECASE)
    vmatch = np.vectorize(lambda x:bool(r.match(x)))
    mask = ~vmatch(field_names) # mask is true where field name doesn't contain 'time' or 'patient'
    return data[field_names[mask]]


def readFileAsIs(filePath):
    newFile = open(filePath, 'r')
    reader = csv.reader(newFile)
    allLines = [row for row in reader]
    newFile.close()
    return allLines

def createFeatures(outputDir = UNIFIED_TABLES_PATH):
    #define the aggregators for each table
    aggregatorsListLong = [statisticsForAllColoumns, waveletCompressForAllColoumns, numSubWindowsInFreqRange]
    aggregatorsListShort = [numSamplesInFreqRange]
    aggregatorsListEntire = [statisticsForAllColoumns, waveletCompressForAllColoumns, averageOnWindows]

    #initialize
    dataMatrix = dict()
    labelsMatrix = dict()
    aggregatedSubWindows = dict()
    aggregatedWindows = dict()
    aggregatedLabels = dict()
    #create 5 sec per line table, per person
    for patient in PATIENTS_test: # TODO: change back to PATIENTS!
        #read patient data, separate between actual features and labels
        patientData = readFileToFloat(os.path.join(outputDir, "DATAFILE_" + patient + ".csv"))
        names = np.array(patientData.dtype.names)
        labelField = names[np.where((names == 'Is_Sick'))]
        dataFields = names[np.where((names != 'Is_Sick'))]
        patientLabels = patientData[list(labelField)]
        patientData = patientData[list(dataFields)]

        # insert data into matrix
        labelsMatrix[patient] = patientLabels
        dataMatrix[patient] = patientData

        #divide to windows, and reduce/aggregate every window into a line.

        dataSubWindows = divideToWindows(patientData, SHORT_TIME_WINDOW) # dataSubWindows is a list of structured arrays.


        aggregatedSubWindows[patient] = (createTimeWindowTable(aggregatorsListShort, 'short', dataSubWindows, None)) #TODO check if easy to return the table

        #write to patient file
        shortAggregatedFile = open(os.path.join(outputDir, "SHORTFILE_" + patient + ".csv"), 'w')
        writer = csv.writer(shortAggregatedFile, lineterminator='\n')
        patientTable = aggregatedSubWindows[patient] # every line is the reduction of a 5 sec window of current patient's data
        writer.writerow(patientTable.dtype.names)
        writer.writerows(patientTable)


    #create 5 min per line table
    if not len(PATIENTS_test) == len(dataMatrix):
        print len(PATIENTS_test), len(dataMatrix)
        exit(1)
    # for patient, patientData in zip(PATIENTS, dataMatrix):
    for patient, patientData in dataMatrix.items():
        longAggregatedFile = open(os.path.join(outputDir, "LONGFILE_" + patient + ".csv"), 'w')
        total_data_length = (len(patientData))
        num_windows = total_data_length/LONG_TIME_WINDOW
        num_subwindows_per_entire = total_data_length/SHORT_TIME_WINDOW
        num_subwindows_per_window = num_subwindows_per_entire/num_windows
        # logger.info("long window len: {}, subwindow len: {}".format(LONG_TIME_WINDOW, SHORT_TIME_WINDOW))
        # logger.info("total_data_length: ".format(total_data_length))
        # logger.info("num_windows: ".format(num_windows))
        # logger.info("num_subwindows_per_entire: ".format(num_subwindows_per_entire))
        # logger.info("num_subwindows_per_window: ".format(num_subwindows_per_window))
        #DATA_LEN/LONG_TIME_WINDOW WINDOWS
        dataWindows = divideToWindows(patientData, LONG_TIME_WINDOW)
        # logger.info("window length: {}".format(len(dataWindows[0])))
        #(DATA_LEN/SHORT_TIME_WINDOW)/(LONG_TIME_WINDOW/SHORT_TIME_WINDOW) WINDOWS = DATA_LEN/LONG_TIME
        subWindows = divideToWindows(aggregatedSubWindows[patient], LONG_TIME_WINDOW/SHORT_TIME_WINDOW)
        # logger.info("(aggr'd)subWindow length: {}".format(len(subWindows[0])))
        # logger.info("num windows: {}, num aggr'd subwindows windows: {}".format(len(dataWindows), len(subWindows)))

        aggregatedWindows[patient] = (createTimeWindowTable(aggregatorsListLong, 'long', dataWindows, subWindows))
        aggregatedLabels[patient] = len(aggregatedWindows[patient]) * [(patient in SICK_PATIENTS)]

        writer = csv.writer(longAggregatedFile, lineterminator='\n')
        patientTable = aggregatedSubWindows[patient] # every line is the reduction of a 5 min window of current patient's data
        writer.writerow(patientTable.dtype.names)
        writer.writerows(patientTable)

    #create patient per line table
    #patientWindowsList = divideToPatients(dataMatrix, LongWindowsMatrix) not necesssary any more
    for patient, patientData in dataMatrix.items():
        entireAggregatedFile = open(os.path.join(outputDir, "ENTIREFILE_" + patient + ".csv"), 'w')
        aggregatedAll = createTimeWindowTable(aggregatorsListEntire, 'entire', patientData, aggregatedWindows[patient])
        writer = csv.writer(entireAggregatedFile, lineterminator='\n')
        writer.writerow(aggregatedAll.dtype.names)
        writer.writerows(aggregatedAll)
    entireLabels = [(patient in SICK_PATIENTS) for patient in dataMatrix.keys()]
    aggregatedWindowsLabels = []
    [aggregatedWindowsLabels.extend(labels) for labels in aggregatedLabels.values()]
    with open(os.path.join(outputDir, "ENTIRE_LABELS.csv"), 'w') as file:
        writer = csv.writer(file, lineterminator='\n')
        writer.writerow(entireLabels)

    with open(os.path.join(outputDir, "AGGREGATED_LABELS.csv"), 'w') as file:
        writer = csv.writer(file, lineterminator='\n')
        writer.writerow(aggregatedWindowsLabels)

if __name__ == "__main__":
    createFeatures()